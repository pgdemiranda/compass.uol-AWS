# Resumo da Sprint 2

A Sprint 2 foi dividida em duas semanas. A primeira semana esteve relacionado a um conteúdo extenso de Python; a segunda semana esteve relacionado essencialmente a realização dos exercícios e do desafio envolvendo análise de dados.

- **Python**: o curso de Python foi bastante extenso, pude rever conceitos básicos das estruturas de dados e diferentes métodos para interagir com essa estruturas, foi disponibilizado bastante conteúdo sobre dois paradigmas de programação, Programação Orientada a Objeto e Programação Funcional.

- **Ciência de Dados**: o curso de Ciência de Dados foi breve e trouxe lições com bibiotecas Python para trabalhar com manipulação e visualização de dados.

> Já conhecíamos o conteúdo dessa sprint, mas as baterias de exercĩcio da trilha nos fez rever com muita atenção as lições, especialmente do curso de Python. Foi uma boa maneira de exercitar nosso conhecimento.

# Sumário
- [Desafio](#desafio)
- [Exercícios](#exercícios)
    - [Python Básico](#exercícios-python-básico)
    - [Python Avançado I](#exercícios-python-avançado-i)
    - [Python Avançado II](#exercícios-python-avançado-ii)
    - [ETL](#exercícios-python-etl)
- [Evidências](#evidências)
    - [Python Básico](#amostras-python-básico)
    - [Python Avançado I](#amostras-python-avançado-i)
    - [Python Avançado II](#amostras-python-avançado-ii)
    - [ETL](#amostras-python-etl)
- [Certificados](#certificados)

# Desafio

O README.md, bem como os arquivos pertinentes ao Desafio se encontram na pasta [Desafio](./Desafio/)

O desafio dessa sprint foi em torno de Análise de Dados, envolvendo duas etapas: na primeira etapa preparamos **o ambiente** para receber um dataset; e na segunda etapa, após importar o dataset disponibilizado, foi requisitada a limpeza e exploração dos dados, envolvendo as bibliotecas Pandas, para a manipulação de dados, e Matplotlib com a finalidade de visualizar esses dados.

Todas as evidências do desafio se encontra na própria pasta de [Evidências](./Evidências/)

> Em termos de dificuldades, o desafio em si não foi complicado. Não envolve nenhum código complicado seja em Python puro ou nas suas bibliotecas. A dificuldade esteve no planejamento e na ausência de uma **Regra de Negócio**. A dificuldade desse Desafio esteve em avaliar quais dados são pertinentes, o que devemos informar, quais *insights* podem surgir de um dataset onde não sabemos quais dados podem ser retirados, ou como devem ser manipulados. O monitor dessa sprint foi EXEMPLAR ao discutir quais seriam as regras de negócio que poderíamos utilizar para o Desafio. 

# Exercícios

Foram realizadas quatro bateria de exercícios e para cada uma delas estão disponibilizados os arquivos com a resolução dos arquivos no formato **.py**, além das evidências em formato **.png**. Excepcionalmente para a bateria de "ETL com Python" a resolução dos arquivos foi disponibilizada em um Jupyter Notebook no formato **.ipynb** e o output das questões armazenadas em arquivos **.txt** conforme requisitado.

Todos os arquivos dos exercícios, bem como as evidências, podem ser encontrados na pasta [Exercícios](./Exercícios/), abaixo fornecemos o caminho para cada bateria específica:

- [Pasta para os exercícios de Python Básico](./Exercícios/basico/)

- [Pasta para os exercícios de Python Avançado I](./Exercícios/avancado_I/)

- [Pasta para os exercícios de Python Avançado II](./Exercícios/avancado_II/)

- [Pasta para os exercícios de ETL com Python](./Exercícios/etl/)

## Exercícios Python Básico
1. Resposta do exercício 1:
- [Exercício 1](./Exercícios/basico/ex1.py)

2. Resposta do exercício 2:
- [Exercício 2](./Exercícios/basico/ex2.py)

3. Resposta do exercício 3:
- [Exercício 3](./Exercícios/basico/ex3.py)

4. Resposta do exercício 4:
- [Exercício 4](./Exercícios/basico/ex4.py)

5. Resposta do exercício 5:
- [Exercício 5](./Exercícios/basico/ex5.py)

6. Resposta do exercício 6:
- [Exercício 6](./Exercícios/basico/ex6.py)

7. Resposta do exercício 7:
- [Exercício 7](./Exercícios/basico/ex7.py)

8. Resposta do exercício 8:
- [Exercício 8](./Exercícios/basico/ex8.py)

9. Resposta do exercício 9:
- [Exercício 9](./Exercícios/basico/ex9.py)

10. Resposta do exercício 10:
- [Exercício 10](./Exercícios/basico/ex10.py)

11. Resposta do exercício 11:
- [Exercício 11](./Exercícios/basico/ex11.py)

12. Resposta do exercício 12:
- [Exercício 12](./Exercícios/basico/ex12.py)

13. Resposta do exercício 13:
- [Exercício 13](./Exercícios/basico/ex13.py)

14. Resposta do exercício 14:
- [Exercício 14](./Exercícios/basico/ex14.py)

## Exercícios Python Avançado I
15. Resposta do exercício 15:
- [Exercício 15](./Exercícios/avancado_I/ex15.py)

16. Resposta do exercício 16:
- [Exercício 16](./Exercícios/avancado_I/ex16.py)

17. Resposta do exercício 17:
- [Exercício 17](./Exercícios/avancado_I/ex17.py)

18. Resposta do exercício 18:
- [Exercício 18](./Exercícios/avancado_I/ex18.py)

19. Resposta do exercício 19:
- [Exercício 19](./Exercícios/avancado_I/ex19.py)

## Exercícios Python Avançado II
20. Resposta do exercício 20:
- [Exercício 20](./Exercícios/avancado_II/ex20.py)

21. Resposta do exercício 21:
- [Exercício 21](./Exercícios/avancado_II/ex21.py)

22. Resposta do exercício 22:
- [Exercício 22](./Exercícios/avancado_II/ex22.py)

23. Resposta do exercício 23:
- [Exercício 23](./Exercícios/avancado_II/ex23.py)

24. Resposta do exercício 24:
- [Exercício 24](./Exercícios/avancado_II/ex24.py)

25. Resposta do exercício 25:
- [Exercício 25](./Exercícios/avancado_II/ex25.py)

26. Resposta do exercício 26:
- [Exercício 26](./Exercícios/avancado_II/ex26.py)

## Exercícios Python ETL
Jupyter notebook com as respostas das questões de ETL
- [ETL com Python](./Exercícios/etl/etl.ipynb)

1. Etapa-1:
[txt etapa-1](./Exercícios/etl/etapa-1.txt)

2. Etapa-2:
[txt etapa-2](./Exercícios/etl/etapa-2.txt)

3. Etapa-3:
[txt etapa-3](./Exercícios/etl/etapa-3.txt)

4. Etapa-4:
[txt etapa-4](./Exercícios/etl/etapa-4.txt)

5. Etapa-5:
[txt etapa-5](./Exercícios/etl/etapa-5.txt)

# Evidências
## Amostras Python Básico
1. O código implementado retorna apenas os números ímpares ao realizar um loop for iterando sobre a lista recebida e verificando quais números que o resto da divisão por 2 é igual a 0 (usamos aqui o operador de módulo) e adicionamos o resultado a uma lista nova. A amostra traz o código rodando e passando no teste:

![amostra exercício 1](./Exercícios/basico/evidencias/amostra-1.png)

2. Para obtermos listas com palavras que são e não são palíndromos, foi implementado um loop for que inverte as palavras e compara com as palavras originais `if palavra == palavra[::-1]`. Quando elas são iguais, são adicionadas a uma lista, e quando não são, foram colocadas em uma lista diferente. Ambas as listas são impressas em separado. Abaixo a amostra prova que o código roda sem problemas no teste:

![amostra exercício 2](./Exercícios/basico/evidencias/amostra-2.png)

3. Aqui recebemos três listas, uma com os primeiros nomes, outra com os sobrenomes e uma terceira com as idades. Criamos o índice da primeira lista com a função `enumerate()` e, sabendo que cada lista continha o mesmo número de elementos e que dizia respeito aos elementos de uma mesma pessoa, só recuperamos a posição dessas listas de acordo com o índice estabelecido. O código roda sem problemas, como disponível na testagem da amostra abaixo:

![amostra exercício 3](./Exercícios/basico/evidencias/amostra-3.png)

4. O código aqui elimina os elementos duplicados da lista recebido transformando primeiro ela em um set, um conjunto que não admite duplicatas, que depois é transformado novamente em lista. O código rodou sem problemas e passou no teste, conforme a amostra abaixo:

![amostra exercício 4](./Exercícios/basico/evidencias/amostra-4.png)

5. Aqui o código realiza tarefas simples de leitura e print de um arquivo json. É possível conferir a testagem positiva na amostra abaixo:

![amostra exercício 5](./Exercícios/basico/evidencias/amostra-5.png)

6. Para esse exercício o nosso código é uma função que recebe uma lista e aplica uma potência de 2 a cada um dos elementos dessa lista. A amostra abaixo prova que nosso código roda passando pelo teste:

![amostra exercício 6](./Exercícios/basico/evidencias/amostra-6.png)

7. O exercício é simples, apenas abrir e ler um arquivo .txt mas o código não passava nos testes. descobrimos que um espaçamento no final do print, por alguma razão, evitava que o teste aprovasse o código, o que só foi possível após ajustar o print para evitar o espaçamento, como aparece na amostra abaixo:

![amostra exercício 7](./Exercícios/basico/evidencias/amostra-7.png)

8. Aqui escrevemos uma função que recebeu uma série de parâmetros nomeados e não nomeados e que foi capaz de imprimir o valor de cada um dos parâmetros recebidos, como prova a amostra abaixo:

![amostra exercício 8](./Exercícios/basico/evidencias/amostra-8.png)

9. Para o exercício implementamos uma classe Lampada que recebe valores booleanos (True ligada, False desligada) e com três métodos de implementação que muda os estados dela. A classe passou nos três testes e imprime o output desejado, a amostra à seguir traz o sucesso nos três testes:

![amostra exercício 9](./Exercícios/basico/evidencias/amostra-9.png)

10. A função recebe uma sequência de números como string, converte de string para números inteiros, soma todos e retorna a soma dos números. Abaixo segue a amostra com o sucesso do teste: 

![amostra exercício 10](./Exercícios/basico/evidencias/amostra-10.png)

11. Para esse exercício, criamos uma função que divide uma lista em três partes iguais baseado no número de elementos recebidos na lista (para isso usamos a função `len()`) e fizemos uma divisão desses elementos em três. Á partir daí, o que fizemos foi só uma questão de fatiar a lista. Abaixo evidenciamos que o código passa no teste:

![amostra exercício 11](./Exercícios/basico/evidencias/amostra-11.png)

12. A solução desse exercício foi simples porque foi uma questão de compreensão das estruturas de dados com Python. Usamos a função `values()` para extrair os valores do dicionário fornecido, que em seguida é transformado em um set, que por natureza não aceita valores repetidos, e em seguida transformado novamente em lista. A amostra evidencia que o nosso código passou no teste:

![amostra exercício 12](./Exercícios/basico/evidencias/amostra-12.png)

13. Para esse exercício a dificuldade foi apenas a implementação da Média e da Mediana, já que por regra não podemos importar nenhuma biblioteca. A biblioteca random foi implementada pelo próprio exercício e que cria uma lista de 50 números aleatórios em um range de 0 a 500 e precisamos retornar o valor mínimo, o valor máximo, o valor médio e a mediana dessa lista aleatória. O mínimo foi obtido com a função `min()`, o máximo com a função `max()`, e com a função `sum()` e `len()` conseguimos calcular a média. Para a mediana só foi preciso saber se o número final era par ou ímpar, o que soubemos com um if. Por fim, o resultado foi apresentado com um print na sequência requisitada. A amostra prova que o código passou no teste:

![amostra exercício 13](./Exercícios/basico/evidencias/amostra-13.png)

14. O código é bem simples, só foi necessário inverter uma lista, a solução é igual ao que fizemos no exercício do palíndromo e o resultado passou no teste como mostra a evidência à seguir:

![amostra exercício 14](./Exercícios/basico/evidencias/amostra-14.png)


## Amostras Python Avançado I
15. As classes `Pato()` e `Pardal()` herdam da classe `Passaro` dois métodos, `voar()` e `emitir_som()`, e sobreescrevem o método `emitir_som()`. No final, a questão espera uma saída que instancia as duas classes Pato e Pardal, imprime no output uma sequência que inclui a saída da sobrescrição do método `emitir_som()`. A amostra abaixo mostra que o códgo passou em todos os testes:

![amostra exercício 15](./Exercícios/avancado_I/evidencias/amostra-15.png)

16. O código utiliza properties para criar um getter e um setter para o controle da classe Pessoa, protegendo o acesso ao atributo __nome, realizando validações mas sem alterar publicamente a interface. O código foi testado usando  o exemplo:

```
pessoa = Pessoa(0) 
pessoa.nome = 'Fulano De Tal'
print(pessoa.nome)
```

![amostra exercício 16](./Exercícios/avancado_I/evidencias/amostra-16.png)

17. O código implementa uma classe `Cálculo` com dois métodos básicos simples de `adicao()` e de `subtracao()` imprimindo os resultados formatados. O output mostra que o código passou nos testes e rodou com as variáveis x e y fornecidas na questão:

![amostra exercício 17](./Exercícios/avancado_I/evidencias/amostra-17.png)

18. O código abaixo implementa uma classe chamada `Ordenadora` e que pode ser instanciada para ordenar uma lista de forma `crescente` através do método `ordenacaoCrescente` ou de forma `decrescente` através do método `ordenacaoDecrescente`. Abaixo uma amostra do código rodando com a testagem em positivo:      

![amostra exercício 18](./Exercícios/avancado_I/evidencias/amostra-18.png)

19. O código implementa uma classe `Aviao` que recebe os atributos  `modelo`, `velocidade_maxima` e `capacidade`, no qual o atributo cor seja sempre Azul. Ao receber uma lista de atributos, o código imprime no output os atributos em uma ordem requisitada na questão. Abaixo uma amostra do código rodando e passando pelo teste:

![amostra exercício 19](./Exercícios/avancado_I/evidencias/amostra-19.png)

## Amostras Python Avançado II
20. O código abaixo lê um arquivo e armazena o conteúdo na variável linhas, o converte para inteiros e filtra apenas os números pares com a ajuda das funções `map()` e `filter()`. Em seguida, os números são colocados em ordem decrescente e apenas o top 5 é selecionado. No final, é disponibilizazdo a soma dos 5 maiores números pares e a somaa deles. A priori a grande dificuldade de fazer esse código passar pelos testes foi saber que o nome do arquivo é **number.txt**, o que só foi conseguido lendo o retorno no cconsole de testes, mas abaixo é possível examinar que o código volta com todos os testes funcionando:

![amostra exercício 20](./Exercícios/avancado_II/evidencias/amostra-20.png)

21. A função `conta_vogais()` filtra dentro de uma string quais letras são vogais: com a ajuda de uma função lambda e `filter()` e depois retorna essa seleção como lista usando a função `list()`, para daí retornar a quantidade de elementos dentro dessa lista com a função `len()`. A amostra abaixo mostra o código rodando e passando em todos os testes: 

![amostra exercício 21](./Exercícios/avancado_II/evidencias/amostra-21.png)

22. A função `calcula_saldo()` reduz cada produto ao seu preço utilizando a função `map()` e armazenando na variável valores e depois itera cada item somando os valores armazenados na variável valores com o próximo item com a ajuda da função importada `reduce()`, e o código é aprovado nos testes como pode ser observado abaixo:

![amostra exercício 22](./Exercícios/avancado_II/evidencias/amostra-22.png)

23. O código realiza diferentes operações com funções lambda e retorna o valor máximo dentre elas. As funções `map()` e `zip()` são usadas para aplicar as operações a cada par e combinar os operadores com seus pares de operandos, respectivamente. Por fim a função `max()` retorna o valor máximo. Abaixo nosso código roda passando por todos os testes:

![amostra exercício 23](./Exercícios/avancado_II/evidencias/amostra-23.png)

24. Esse foi um exercício difícil não pelo enunciado, mas pelos ajustes necessários para rodar nos testes. Foi requisitado uma listagem ordenada com o nome dos alunos, as três maiores notas listadas de maneira decrescente e a média dessas notas disponibilizada em até a segunda casa decimal. O resultado obtido era válido conforme os requisitos do enunciado da questão (ao utilizar todas as funções pedidas `round()`, `map()` e `sorted()`). Foi criada uma variável `notas_mod` e utilizando uma list comprehesion iteramos em cima da listagem das notas top 3 de cada aluno e convertemos para int todos os valores filtrados com a função `is_integer()` e arredondamos para uma casa decimal quem não fosse. A amostra abaixo mostra o código rodando e passando por todos os testes: 

![amostra exercício 24](./Exercícios/avancado_II/evidencias/amostra-24.png)

25. Para esse exercício, a função `maiores_que_media()` filtra e ordena produtos com preço acima da média de um dicionário chamado `conteudo`. Abaixo a amostra evidenciando os testes retornando como positivo para o código:

![amostra exercício 25](./Exercícios/avancado_II/evidencias/amostra-25.png)

26. Para o exercício a função `pares_ate(n:int)` gera números pares, iniciando do 2 até um número n (incluindo ele, daí o n + 1). Abaixo a amostra do exercício aprovado pelo teste:

![amostra exercício 26](./Exercícios/avancado_II/evidencias/amostra-26.png)

## Amostras Python ETL
1. O enunciado da etapa 1 diz: "Apresente o ator/atriz com maior número de filmes e a respectiva quantidade. A quantidade de filmes encontra-se na coluna Number of movies do arquivo". O código desenvolvido abre e lê o arquivo **.csv** como uma lista de dicionário (gerando assim uma relação chave-valor), usa a função `max()` para retornar o valor máximo percorrido com uma função lambda na coluna 'Number of Movies'.

![input etapa 1](./Exercícios/etl/evidencias/etapa1-input.png)

O resultado é gravado no arquivo **etapa-1.txt** com a informação desejada das colunas 'Actor' e 'Number of Movies':

![output etapa 1](./Exercícios/etl/evidencias/etapa1-output.png)

2. O enunciado da etapa 2 pede: "Apresente a média de receita de bilheteria bruta dos principais filmes, considerando todos os atores. Estamos falando aqui da média da coluna Gross". O código abaixo abre o arquivo, converte os dados em uma lista de dicionário, calcula-se a média dividindo a soma dos valores da coluna 'Gross' pelo número de elementos da lista.

![input etapa 2](./Exercícios/etl/evidencias/etapa2-input.png)

O resultado foi então registrado no arquivo **etapa-2.txt** com a média bruta das bilheterias e formatado para apresentar o resultado com duas casas decimais:

![output etapa 2](./Exercícios/etl/evidencias/etapa2-output.png)

3. O enunciado da etapa 3 é a seguinte: "Apresenta o ator/atriz com a maior média de receita de bilheteria bruta por filme do conjunto de dados. Considere a coluna Average per Movie para fins de cálculo". O código lê o arquivo e o converte em uma lista de dicionário e com a ajuda de uma função lambda e da função `max()`, retorna o valor máximo da coluna 'Average per Movie'.

![input etapa 3](./Exercícios/etl/evidencias/etapa3-input.png)

O resultado foi registrado no arquivo **etapa-3.txt** trazendo o nome do ator com o maior valor médio por filme:

![output etapa 3](./Exercícios/etl/evidencias/etapa3-output.png)

4. Para a etapa 4 é requisitado: "A coluna #1 Movie contém o filme de maior bilheteriea em que o autor atuou. Realize a contagem de aparições destes filmes no dataset, listando-os ordenados pela quantidade de vezes em que estão presentes. Considere a ordem decrescente e, em segundo nível, o nome do filme. 

Ao escrever no arquivo, considere o padrão de saída (sequencia) - O filme (nome filme) aparece (quantidade) vez(es) no dataset, adicionando um resultado a cada linha". O código escrito é um pouco mais complexo: ele começa com um dicionário vazio, percorre a lista de filmes adicionando os filmes a essa lista, e se o filme já está lá, o contador é incrementado em um para cada vez que ele aparece de novo na iteração.

![input etapa 4](./Exercícios/etl/evidencias/etapa4-input.png)

O resultado é registrado com a ajuda da função `enumerate()` que recupera o índice da lista, além do nome dos filmes e de quantas vezes foram registradas após a iteração. A função lambda é responsável ainda por ordenar a lista de forma decrescente à partir da quantidade de registros de cada filme. Os registros foram realizados conforme a formatação requisitada:

![output etapa 4](./Exercícios/etl/evidencias/etapa4-output.png)

5. Por fim, para a etapa 5 o enunciado pede: "Apresente a lista dos atores ordenada pela receita bruta de bilheteria de seus filmes (coluna Total Gross), em ordem decrescente. Ao escrever no arquivo, considere o padrão de saída (nome do ator) - (receita total bruta), adicionando um resultado a cada linha". O código lê os dados, ordena a lista de maneira decrescente pela coluna 'Total Gross' com a ajuda de uma função lambda, mantendo os valores como float para que isso não atrapalhe a ordenação.

![input etapa 5](./Exercícios/etl/evidencias/etapa5-input.png)

Os registros são salvos contendo ordenadamente o nome de cada ator e atriz, e o valor total da receita bruta:

![output etapa 5](./Exercícios/etl/evidencias/etapa5-output.png)

# Certificados
Não foi realizado nenhum curso fora da plataforma Udemy, portanto não foi necessário apresentar nenhum certificado.